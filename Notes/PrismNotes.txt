--------------------------------------------------------------------------------------------------------------------------------------------

THE BOOTSTRAPPER

Initialises the application
Initialises the Core Services
Initialises the application specific services

THE BOOTSPRAPPING PROCESS

Create the LoggerFacade
Create and Configure the Module Catalog
Create and Configure the Container i.e. Unity
Configure the default Region Adapter Mappings 
Configure Region Behaviours
Register the Framewok Exception Types
Create the Shell
Initialise the Shell
Initialise Modules

TO GET THE BOOTSTRAPPER TO WORK YOU MUST

Remove the StartupUri attribute from the Window XAML as the Bootstrapper will initialise and show the Shell instead
Override the Application.OnStartup in which the Bootstrapper must be instantiated.
Add the statement [using Microsoft.Practices.Unity;] to the Bootstrapper.cs for the Container.Resolve<T>

use Application.Current.MainWindow = (Window)Shell; in the override of Bootstrapper.InitializeShell() to cast 
the dependency object to the application window.

--------------------------------------------------------------------------------------------------------------------------------------------

PRISM CORE SERVICES

--------------------------------------------------------------------------------------------------------------------------------------------

PRISM CORE INTERFACES

IModuleManager
IModuleCatalog
IModuleInitializer
IRegionManager
IEventAggregator
ILoggerFacade
IServiceLocator

--------------------------------------------------------------------------------------------------------------------------------------------

THE SHELL

Is a Window user control
In it you define Regions into which Views will be injected at runtime

--------------------------------------------------------------------------------------------------------------------------------------------

REGION -REGION MANAGER - REGION ADAPTER
REGION NAME ATTACHED PROPERTY
REGION CONTEXT ATTACHED PROPERTY


Regions are managed by a RegionManager.
Regions are not controls.
A region implements IRegion.

The RegionManager maintsins a collection of regions and creates regions for controls.
The RegionManager provides the RegionName attached property.
The RegionManager.RegionName attached property is applied to a host control via XAML or code.
The RegionManager maps Region Adapters to Controls.

The RegionManager.Context attached property is similar to the concept fo DataContext.
The RegionManager.Context is used to share data between a parent/child views hosted between a region.
The RegionManager.Context can be set through code or through XAML.

A RegonAdapter is responsible for associating a Region with a host control.
In order to expose a UI control as a region a Region Adapter must be defined for the UI control.

The default RegionAdaper in Prism are
	ContentControlRegionAdapter
	ItemControlRegionAdapter
	SelectorRegionAdapter

-------------------------------------------------------------------------------------------------------------------------------------------

CREATE A SCOPED REGION MANAGER - NECESSARY WHEN USING MULTIPLE SHELLS

Prism uses a global RegionManager instance by default and that instance is injected via DI into modules.
In IModules.Initialise() the reference to the global region manager is used to retrive the regions of the
Shell by their name (key) and then the views of the modules are added to corresponding regions of the shell. 
We cannot add the same two identical region names to the same instance of the RegionManager and this may 
cause exceptions when modules add their views to the global region manager when the added view has child
views also registered to regions of the global region manager. In order to prevent this kind of exceptions 
any module should rather use a dedicated instance of the region manager that is not the global 


Method 1 - use the IRegion.Add overload to return a scoped region manager 

IRegion region = regionManager.Regions["SomeRegionName"];
View view = container.Resolve<View>();
// IRegion.Add(-,-,true)
IRegionManager scopedRegion = region.Add(view, null, true);

Method 2 - use IRegionManager.CreateRegionManager() to obtained a scope region
		   use IRegionManager.SetRegionManager to set a scope region for a view

IRegionManager scopedRegion = regionManager.CreateRegionManager();
View view = container.Resolve<View>();
ResionManager.SetRegionManager(voew, scopedRegion)

-------------------------------------------------------------------------------------------------------------------------------------------

CREATE A CUSTOM REGION ADAPTER

For any control other than ContentControl, ItemControl or Selector controls for which Prism comes with built-in Region Adapters
a Custom Region Adapter is required.

Derive from RegionAdapterBase<T> where T is the type of the host control for the CustomRegion

Provide a PUBLIC constructor such as
public RegionAdapterStackPanel(IRegionBehaviorFactory regionBehaviorFactory) 
			: base(regionBehaviorFactory) {

		}

Implement RegionAdapterBase<T>.CreateRegion which can return
	SingleActiveRegion	=> allows none or one ACTIVE view at any one time => used for ContentControl
	AllActiveRegion		=> all the views are ACTIVE and DEACTIVATION of views is NOT ALLOWED => used for ItemControl
	Region				=> allows multiple active views => used for SelectorControl

Implement RegionAdapterBase<T>.Adapt

Register the RegionAdapter with the Bootstrapper
override RegionAdapterMappings ConfigureRegionAdapterMappings() and return the base class mappings with the addition 
of the Custom Region Adapter

-------------------------------------------------------------------------------------------------------------------------------------------

MODULES
http://prismlibrary.readthedocs.io/en/latest/WPF/04-Modules/

Modules are implemented in WPF User Control Libraries.
In the library a single class implementing IModule exits.

MODULES LIFETIME = REGISTRATION => DISCOVERY => REGISTRATION => LOADING

THE MODULE CATALOG

A ModuleCatalog is used to maintain a collection of loaded modules.
The ModuleCatalog knows the location of each module.
The ModuleCatalog knows the order in which all modules are loaded.
The ModuleCatalog knows all the dependencies between modules.
A ModuleCatalog is instantiated in the Bootstrapper.ConfigureModuleCatalog override.

REGISTER MODULES
 
From Code
From XAML
From a Configuartion File.
From Dsik by specifying a directory from which compiled module assembly may be loaded at runtime. 

LOAD MODULES

Modules can be loaded from Disk or from a remote location such as a shared directory.

Modules can be loaded in two ways
	When Available
	On Demand


INITIALISE MODULES

Make a module ready for comsumption in a Prims application

IModule.Initialize() =>
	Register types
	Subscribe to Services or Events
	Register Shared Services
	Compose Views into the Shell

--------------------------------------------------------------------------------------------------------------------------------------------

BindableBase 

Refs
https://stackoverflow.com/questions/28844518/bindablebase-vs-inotifychanged

Bindablebase is an abstract class that implements INotifyPropertyChanged interface and provide SetProperty<T>.You can reduce the set method 
to just one line also ref parameter allows you to update its value. 

--------------------------------------------------------------------------------------------------------------------------------------------
