--------------------------------------------------------------------------------------------------------------------------------------------

THE BOOTSTRAPPER

Initialises the application
Initialises the Core Services
Initialises the application specific services

THE BOOTSPRAPPING PROCESS

Create the LoggerFacade
Create and Configure the Module Catalog
Create and Configure the Container i.e. Unity
Configure the default Region Adapter Mappings 
Configure Region Behaviours
Register the Framewok Exception Types
Create the Shell
Initialise the Shell
Initialise Modules

TO GET THE BOOTSTRAPPER TO WORK YOU MUST

Remove the StartupUri attribute from the Window XAML as the Bootstrapper will initialise and show the Shell instead
Override the Application.OnStartup in which the Bootstrapper must be instantiated.
Add the statement [using Microsoft.Practices.Unity;] to the Bootstrapper.cs for the Container.Resolve<T>

use Application.Current.MainWindow = (Window)Shell; in the override of Bootstrapper.InitializeShell() to cast 
the dependency object to the application window.

--------------------------------------------------------------------------------------------------------------------------------------------

PRISM CORE SERVICES

--------------------------------------------------------------------------------------------------------------------------------------------

PRISM CORE INTERFACES

IModuleManager
IModuleCatalog
IModuleInitializer
IRegionManager
IEventAggregator
ILoggerFacade
IServiceLocator

--------------------------------------------------------------------------------------------------------------------------------------------

THE SHELL

Is a Window user control
In it you define Regions into which Views will be injected at runtime

--------------------------------------------------------------------------------------------------------------------------------------------

REGION -REGION MANAGER - REGION ADAPTER
REGION NAME ATTACHED PROPERTY
REGION CONTEXT ATTACHED PROPERTY


Regions are managed by a RegionManager.
Regions are not controls.
A region implements IRegion.

The RegionManager maintsins a collection of regions and creates regions for controls.
The RegionManager provides the RegionName attached property.
The RegionManager.RegionName attached property is applied to a host control via XAML or code.
The RegionManager maps Region Adapters to Controls.

The RegionManager.Context attached property is similar to the concept fo DataContext.
The RegionManager.Context is used to share data between a parent/child views hosted between a region.
The RegionManager.Context can be set through code or through XAML.

A RegonAdapter is responsible for associating a Region with a host control.
In order to expose a UI control as a region a Region Adapter must be defined for the UI control.

The default RegionAdaper in Prism are
	ContentControlRegionAdapter
	ItemControlRegionAdapter
	SelectorRegionAdapter

-------------------------------------------------------------------------------------------------------------------------------------------

CREATE A SCOPED REGION MANAGER - NECESSARY WHEN USING MULTIPLE SHELLS

Prism uses a global RegionManager instance by default and that instance is injected via DI into modules.
In IModules.Initialise() the reference to the global region manager is used to retrive the regions of the
Shell by their name (key) and then the views of the modules are added to corresponding regions of the shell. 
We cannot add the same two identical region names to the same instance of the RegionManager and this may 
cause exceptions when modules add their views to the global region manager when the added view has child
views also registered to regions of the global region manager. In order to prevent this kind of exceptions 
any module should rather use a dedicated instance of the region manager that is not the global 


Method 1 - use the IRegion.Add overload to return a scoped region manager 

IRegion region = regionManager.Regions["SomeRegionName"];
View view = container.Resolve<View>();
// IRegion.Add(-,-,true)
IRegionManager scopedRegion = region.Add(view, null, true);

Method 2 - use IRegionManager.CreateRegionManager() to obtained a scope region
		   use IRegionManager.SetRegionManager to set a scope region for a view

IRegionManager scopedRegion = regionManager.CreateRegionManager();
View view = container.Resolve<View>();
ResionManager.SetRegionManager(voew, scopedRegion)

-------------------------------------------------------------------------------------------------------------------------------------------

CREATE A CUSTOM REGION ADAPTER

For any control other than ContentControl, ItemControl or Selector controls for which Prism comes with built-in Region Adapters
a Custom Region Adapter is required.

Derive from RegionAdapterBase<T> where T is the type of the host control for the CustomRegion

Provide a PUBLIC constructor such as
public RegionAdapterStackPanel(IRegionBehaviorFactory regionBehaviorFactory) 
			: base(regionBehaviorFactory) {

		}

Implement RegionAdapterBase<T>.CreateRegion which can return
	SingleActiveRegion	=> allows none or one ACTIVE view at any one time => used for ContentControl
	AllActiveRegion		=> all the views are ACTIVE and DEACTIVATION of views is NOT ALLOWED => used for ItemControl
	Region				=> allows multiple active views => used for SelectorControl

Implement RegionAdapterBase<T>.Adapt

Register the RegionAdapter with the Bootstrapper
override RegionAdapterMappings ConfigureRegionAdapterMappings() and return the base class mappings with the addition 
of the Custom Region Adapter

-------------------------------------------------------------------------------------------------------------------------------------------

MODULES
http://prismlibrary.readthedocs.io/en/latest/WPF/04-Modules/

Modules are implemented in WPF User Control Libraries.
In the library a single class implementing IModule exits.

MODULES LIFETIME = REGISTRATION => DISCOVERY => REGISTRATION => LOADING

THE MODULE CATALOG

A ModuleCatalog is used to maintain a collection of loaded modules.
The ModuleCatalog knows the location of each module.
The ModuleCatalog knows the order in which all modules are loaded.
The ModuleCatalog knows all the dependencies between modules.
A ModuleCatalog is instantiated in the Bootstrapper.ConfigureModuleCatalog override.

REGISTER MODULES
 
From Code
From XAML
From a Configuartion File.
From Dsik by specifying a directory from which compiled module assembly may be loaded at runtime. 

LOAD MODULES

Modules can be loaded from Disk or from a remote location such as a shared directory.

Modules can be loaded in two ways
	When Available
	On Demand


INITIALISE MODULES

Make a module ready for comsumption in a Prims application

IModule.Initialize() =>
	Register types
	Subscribe to Services or Events
	Register Shared Services
	Compose Views into the Shell

--------------------------------------------------------------------------------------------------------------------------------------------

BindableBase 

Refs
https://stackoverflow.com/questions/28844518/bindablebase-vs-inotifychanged

Bindablebase is an abstract class that implements INotifyPropertyChanged interface and provide SetProperty<T>.You can reduce the set method 
to just one line also ref parameter allows you to update its value. 

--------------------------------------------------------------------------------------------------------------------------------------------

REGION, REGION ADAPTERS AND VIEWS

A Region in Prism is an attached property that may be applied to a control to indicate to Prism that the XAML element to which the AP is 
applied defines a Region and will therefore host some views as its children in the visual tree.

For example

<ContentControl prism:RegionManager.RegionName="{x:Static inf:RegionNames.RegionMainMenu}" Grid.Row="0"/>

Declares that that specifc element of the VT that is a ContentControl is a named region.

For a XAML element to be able to act as a region there must exist a Region Adapter. A Region Adapter is an implementation of an abstract
class RegionAdapterBase<T> where T is the type of XAML element that we would like to act as a region. There is an implementation of a 
custom region RegionAdapterStackPanel in the solution for illustrative purposes. In practice the logic in the Region Adapter specifies two
things.

1-What kind of Region that XAML item is supposed to be. => the RegionAdapterBase.CreateRegion
2-Some logic that handles the addition and removal of views into the XAML element of the region. => RegionAdapterBase.Adapt

In relation to (1) there are really only three types of Region in Prism
1-AllActiveRegion		=> all the views in the region are active i.e. ContentControl has an adapter of this kind.
2-SingleActiveRegion	=> only a single view in the region can be active at any one time i.e. ItemsControl has an adapter of this kind.
3-Region				=> this region allows for multiple active views i.e. controls that derive from teh Selector Class. 

Views in Prism must eventually become visible on the GUI by being associated to a Prism Region. There are three mechanisms by means of which 
a view can be displayed into a region.

1-View Discovery		(automatic injection of views into defined regions of the shell)
2-View Injection		(programmatic injection of views into defined regions of the shell)

1-View Discovery Example	(automatic injection of views into defined regions of the shell)

// In the IModule.initialize regiter a view with a region in the shell and Prism will instantiate
// the view and inject it in the region for you. This is a good mechanism for some parts of the GUI 
// that are permanent. This mechanism does not afford explicit control an when to load and display 
// a view in a region.
public void Initialize() {
            regionManager.RegisterViewWithRegion(RegionNames.RegionContent, typeof(ContentView));
}

2-View Injection	(programmatic injection of views into defined regions of the shell)

IRegionManager rm = manager;
rm.Regions["RegionName"].Add(view,name)

or 

var viewModelForView = container.Resolve(IMyViewModel)
IRegion region = manager.Regions["RegionName"];
var activeView = region.ActiveViews[0];
....
region.Add(viewModelForView.View)

you may need to Activate/Deactive the view(s) in the region. For example, if a defined Prism region has a ContentControl has its host then
it must be of type SingleActiveRegion. You may inject multiple view into such region but only one can be active at any time and you must do
this programmatically. Deactivate the current view, inject the new view and activate it to show it othervwise you won't see it. 

With View Injection you can also remove views from a Region.
The region must exists prior to injecting views into it, you must checj that the region has already being created before you try to inject 
any view into it.

--------------------------------------------------------------------------------------------------------------------------------------------
